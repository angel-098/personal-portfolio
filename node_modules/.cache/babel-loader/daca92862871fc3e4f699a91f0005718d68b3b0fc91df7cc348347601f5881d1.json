{"ast":null,"code":"import { noop } from 'motion-utils';\nimport { GroupAnimation } from '../animation/GroupAnimation.mjs';\nimport { getLayoutElements } from './get-layout-elements.mjs';\nimport { buildProjectionTree, cleanupProjectionTree } from './projection-tree.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\nimport { frame } from '../frameloop/frame.mjs';\nclass LayoutAnimationBuilder {\n  constructor(scope, updateDom, defaultOptions) {\n    this.sharedTransitions = new Map();\n    this.notifyReady = noop;\n    this.executed = false;\n    this.scope = scope;\n    this.updateDom = updateDom;\n    this.defaultOptions = defaultOptions;\n    this.readyPromise = new Promise(resolve => {\n      this.notifyReady = resolve;\n    });\n    // Queue execution on microtask to allow builder methods to be called\n    queueMicrotask(() => this.execute());\n  }\n  shared(id, options) {\n    this.sharedTransitions.set(id, options);\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    return this.readyPromise.then(onfulfilled, onrejected);\n  }\n  async execute() {\n    if (this.executed) return;\n    this.executed = true;\n    let context;\n    // Phase 1: Pre-mutation - Build projection tree and take snapshots\n    const beforeElements = getLayoutElements(this.scope);\n    if (beforeElements.length > 0) {\n      context = buildProjectionTree(beforeElements, undefined, this.getBuildOptions());\n      context.root.startUpdate();\n      for (const node of context.nodes.values()) {\n        node.isLayoutDirty = false;\n        node.willUpdate();\n      }\n    }\n    // Phase 2: Execute DOM update\n    this.updateDom();\n    // Phase 3: Post-mutation - Compare before/after elements\n    const afterElements = getLayoutElements(this.scope);\n    const beforeSet = new Set(beforeElements);\n    const afterSet = new Set(afterElements);\n    const entering = afterElements.filter(el => !beforeSet.has(el));\n    const exiting = beforeElements.filter(el => !afterSet.has(el));\n    // Build projection nodes for entering elements\n    if (entering.length > 0) {\n      context = buildProjectionTree(entering, context, this.getBuildOptions());\n    }\n    // No layout elements - return empty animation\n    if (!context) {\n      this.notifyReady(new GroupAnimation([]));\n      return;\n    }\n    // Handle shared elements\n    for (const element of exiting) {\n      const node = context.nodes.get(element);\n      node?.getStack()?.remove(node);\n    }\n    for (const element of entering) {\n      context.nodes.get(element)?.promote();\n    }\n    // Phase 4: Animate\n    context.root.didUpdate();\n    await new Promise(resolve => frame.postRender(() => resolve()));\n    const animations = [];\n    for (const node of context.nodes.values()) {\n      if (node.currentAnimation) {\n        animations.push(node.currentAnimation);\n      }\n    }\n    const groupAnimation = new GroupAnimation(animations);\n    groupAnimation.finished.then(() => {\n      // Only clean up nodes for elements no longer in the document.\n      // Elements still in DOM keep their nodes so subsequent animations\n      // can use the stored position snapshots (A→B→A pattern).\n      const elementsToCleanup = new Set();\n      for (const element of context.nodes.keys()) {\n        if (!document.contains(element)) {\n          elementsToCleanup.add(element);\n        }\n      }\n      cleanupProjectionTree(context, elementsToCleanup);\n    });\n    this.notifyReady(groupAnimation);\n  }\n  getBuildOptions() {\n    return {\n      defaultTransition: this.defaultOptions || {\n        duration: 0.3,\n        ease: \"easeOut\"\n      },\n      sharedTransitions: this.sharedTransitions.size > 0 ? this.sharedTransitions : undefined\n    };\n  }\n}\n/**\n * Parse arguments for animateLayout overloads\n */\nfunction parseAnimateLayoutArgs(scopeOrUpdateDom, updateDomOrOptions, options) {\n  // animateLayout(updateDom)\n  if (typeof scopeOrUpdateDom === \"function\") {\n    return {\n      scope: document,\n      updateDom: scopeOrUpdateDom,\n      defaultOptions: updateDomOrOptions\n    };\n  }\n  // animateLayout(scope, updateDom, options?)\n  const elements = resolveElements(scopeOrUpdateDom);\n  const scope = elements[0] || document;\n  return {\n    scope: scope instanceof Document ? scope : scope,\n    updateDom: updateDomOrOptions,\n    defaultOptions: options\n  };\n}\nexport { LayoutAnimationBuilder, parseAnimateLayoutArgs };","map":{"version":3,"names":["noop","GroupAnimation","getLayoutElements","buildProjectionTree","cleanupProjectionTree","resolveElements","frame","LayoutAnimationBuilder","constructor","scope","updateDom","defaultOptions","sharedTransitions","Map","notifyReady","executed","readyPromise","Promise","resolve","queueMicrotask","execute","shared","id","options","set","then","onfulfilled","onrejected","context","beforeElements","length","undefined","getBuildOptions","root","startUpdate","node","nodes","values","isLayoutDirty","willUpdate","afterElements","beforeSet","Set","afterSet","entering","filter","el","has","exiting","element","get","getStack","remove","promote","didUpdate","postRender","animations","currentAnimation","push","groupAnimation","finished","elementsToCleanup","keys","document","contains","add","defaultTransition","duration","ease","size","parseAnimateLayoutArgs","scopeOrUpdateDom","updateDomOrOptions","elements","Document"],"sources":["C:/Users/angel/OneDrive/Documents/my-portfolio/node_modules/motion-dom/dist/es/layout/LayoutAnimationBuilder.mjs"],"sourcesContent":["import { noop } from 'motion-utils';\nimport { GroupAnimation } from '../animation/GroupAnimation.mjs';\nimport { getLayoutElements } from './get-layout-elements.mjs';\nimport { buildProjectionTree, cleanupProjectionTree } from './projection-tree.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\nclass LayoutAnimationBuilder {\n    constructor(scope, updateDom, defaultOptions) {\n        this.sharedTransitions = new Map();\n        this.notifyReady = noop;\n        this.executed = false;\n        this.scope = scope;\n        this.updateDom = updateDom;\n        this.defaultOptions = defaultOptions;\n        this.readyPromise = new Promise((resolve) => {\n            this.notifyReady = resolve;\n        });\n        // Queue execution on microtask to allow builder methods to be called\n        queueMicrotask(() => this.execute());\n    }\n    shared(id, options) {\n        this.sharedTransitions.set(id, options);\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        return this.readyPromise.then(onfulfilled, onrejected);\n    }\n    async execute() {\n        if (this.executed)\n            return;\n        this.executed = true;\n        let context;\n        // Phase 1: Pre-mutation - Build projection tree and take snapshots\n        const beforeElements = getLayoutElements(this.scope);\n        if (beforeElements.length > 0) {\n            context = buildProjectionTree(beforeElements, undefined, this.getBuildOptions());\n            context.root.startUpdate();\n            for (const node of context.nodes.values()) {\n                node.isLayoutDirty = false;\n                node.willUpdate();\n            }\n        }\n        // Phase 2: Execute DOM update\n        this.updateDom();\n        // Phase 3: Post-mutation - Compare before/after elements\n        const afterElements = getLayoutElements(this.scope);\n        const beforeSet = new Set(beforeElements);\n        const afterSet = new Set(afterElements);\n        const entering = afterElements.filter((el) => !beforeSet.has(el));\n        const exiting = beforeElements.filter((el) => !afterSet.has(el));\n        // Build projection nodes for entering elements\n        if (entering.length > 0) {\n            context = buildProjectionTree(entering, context, this.getBuildOptions());\n        }\n        // No layout elements - return empty animation\n        if (!context) {\n            this.notifyReady(new GroupAnimation([]));\n            return;\n        }\n        // Handle shared elements\n        for (const element of exiting) {\n            const node = context.nodes.get(element);\n            node?.getStack()?.remove(node);\n        }\n        for (const element of entering) {\n            context.nodes.get(element)?.promote();\n        }\n        // Phase 4: Animate\n        context.root.didUpdate();\n        await new Promise((resolve) => frame.postRender(() => resolve()));\n        const animations = [];\n        for (const node of context.nodes.values()) {\n            if (node.currentAnimation) {\n                animations.push(node.currentAnimation);\n            }\n        }\n        const groupAnimation = new GroupAnimation(animations);\n        groupAnimation.finished.then(() => {\n            // Only clean up nodes for elements no longer in the document.\n            // Elements still in DOM keep their nodes so subsequent animations\n            // can use the stored position snapshots (A→B→A pattern).\n            const elementsToCleanup = new Set();\n            for (const element of context.nodes.keys()) {\n                if (!document.contains(element)) {\n                    elementsToCleanup.add(element);\n                }\n            }\n            cleanupProjectionTree(context, elementsToCleanup);\n        });\n        this.notifyReady(groupAnimation);\n    }\n    getBuildOptions() {\n        return {\n            defaultTransition: this.defaultOptions || {\n                duration: 0.3,\n                ease: \"easeOut\",\n            },\n            sharedTransitions: this.sharedTransitions.size > 0\n                ? this.sharedTransitions\n                : undefined,\n        };\n    }\n}\n/**\n * Parse arguments for animateLayout overloads\n */\nfunction parseAnimateLayoutArgs(scopeOrUpdateDom, updateDomOrOptions, options) {\n    // animateLayout(updateDom)\n    if (typeof scopeOrUpdateDom === \"function\") {\n        return {\n            scope: document,\n            updateDom: scopeOrUpdateDom,\n            defaultOptions: updateDomOrOptions,\n        };\n    }\n    // animateLayout(scope, updateDom, options?)\n    const elements = resolveElements(scopeOrUpdateDom);\n    const scope = elements[0] || document;\n    return {\n        scope: scope instanceof Document ? scope : scope,\n        updateDom: updateDomOrOptions,\n        defaultOptions: options,\n    };\n}\n\nexport { LayoutAnimationBuilder, parseAnimateLayoutArgs };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}