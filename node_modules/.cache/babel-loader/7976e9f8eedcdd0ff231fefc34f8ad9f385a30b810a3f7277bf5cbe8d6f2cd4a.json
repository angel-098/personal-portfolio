{"ast":null,"code":"import { HTMLProjectionNode } from '../projection/node/HTMLProjectionNode.mjs';\nimport { HTMLVisualElement } from '../render/html/HTMLVisualElement.mjs';\nimport { nodeGroup } from '../projection/node/group.mjs';\nimport { getLayoutId } from './get-layout-elements.mjs';\nimport { addScaleCorrector } from '../projection/styles/scale-correction.mjs';\nimport { correctBorderRadius } from '../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../projection/styles/scale-box-shadow.mjs';\nlet scaleCorrectorAdded = false;\n/**\n * Track active projection nodes per element to handle animation interruption.\n * When a new animation starts on an element that already has an active animation,\n * we need to stop the old animation so the new one can start from the current\n * visual position.\n */\nconst activeProjectionNodes = new WeakMap();\nfunction ensureScaleCorrectors() {\n  if (scaleCorrectorAdded) return;\n  scaleCorrectorAdded = true;\n  addScaleCorrector({\n    borderRadius: {\n      ...correctBorderRadius,\n      applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow\n  });\n}\n/**\n * Get DOM depth of an element\n */\nfunction getDepth(element) {\n  let depth = 0;\n  let current = element.parentElement;\n  while (current) {\n    depth++;\n    current = current.parentElement;\n  }\n  return depth;\n}\n/**\n * Find the closest projection parent for an element\n */\nfunction findProjectionParent(element, nodeCache) {\n  let parent = element.parentElement;\n  while (parent) {\n    const node = nodeCache.get(parent);\n    if (node) return node;\n    parent = parent.parentElement;\n  }\n  return undefined;\n}\n/**\n * Create or reuse a projection node for an element\n */\nfunction createProjectionNode(element, parent, options, transition) {\n  // Check for existing active node - reuse it to preserve animation state\n  const existingNode = activeProjectionNodes.get(element);\n  if (existingNode) {\n    const visualElement = existingNode.options.visualElement;\n    // Update transition options for the new animation\n    const nodeTransition = transition ? {\n      duration: transition.duration,\n      ease: transition.ease\n    } : {\n      duration: 0.3,\n      ease: \"easeOut\"\n    };\n    existingNode.setOptions({\n      ...existingNode.options,\n      animate: true,\n      transition: nodeTransition,\n      ...options\n    });\n    // Re-mount the node if it was previously unmounted\n    // This re-adds it to root.nodes so didUpdate() will process it\n    if (!existingNode.instance) {\n      existingNode.mount(element);\n    }\n    return {\n      node: existingNode,\n      visualElement\n    };\n  }\n  // No existing node - create a new one\n  const latestValues = {};\n  const visualElement = new HTMLVisualElement({\n    visualState: {\n      latestValues,\n      renderState: {\n        transformOrigin: {},\n        transform: {},\n        style: {},\n        vars: {}\n      }\n    },\n    presenceContext: null,\n    props: {}\n  });\n  const node = new HTMLProjectionNode(latestValues, parent);\n  // Convert AnimationOptions to transition format for the projection system\n  const nodeTransition = transition ? {\n    duration: transition.duration,\n    ease: transition.ease\n  } : {\n    duration: 0.3,\n    ease: \"easeOut\"\n  };\n  node.setOptions({\n    visualElement,\n    layout: true,\n    animate: true,\n    transition: nodeTransition,\n    ...options\n  });\n  node.mount(element);\n  visualElement.projection = node;\n  // Track this node as the active one for this element\n  activeProjectionNodes.set(element, node);\n  return {\n    node,\n    visualElement\n  };\n}\n/**\n * Build a projection tree from a list of elements\n */\nfunction buildProjectionTree(elements, existingContext, options) {\n  ensureScaleCorrectors();\n  const nodes = existingContext?.nodes ?? new Map();\n  const visualElements = existingContext?.visualElements ?? new Map();\n  const group = existingContext?.group ?? nodeGroup();\n  const defaultTransition = options?.defaultTransition;\n  const sharedTransitions = options?.sharedTransitions;\n  // Sort elements by DOM depth (parents before children)\n  const sorted = [...elements].sort((a, b) => getDepth(a) - getDepth(b));\n  let root = existingContext?.root;\n  for (const element of sorted) {\n    // Skip if already has a node\n    if (nodes.has(element)) continue;\n    const parent = findProjectionParent(element, nodes);\n    const layoutId = getLayoutId(element);\n    const layoutMode = element.getAttribute(\"data-layout\");\n    const nodeOptions = {\n      layoutId: layoutId ?? undefined,\n      animationType: parseLayoutMode(layoutMode)\n    };\n    // Use layoutId-specific transition if available, otherwise use default\n    const transition = layoutId && sharedTransitions?.get(layoutId) ? sharedTransitions.get(layoutId) : defaultTransition;\n    const {\n      node,\n      visualElement\n    } = createProjectionNode(element, parent, nodeOptions, transition);\n    nodes.set(element, node);\n    visualElements.set(element, visualElement);\n    group.add(node);\n    if (!root) {\n      root = node.root;\n    }\n  }\n  return {\n    nodes,\n    visualElements,\n    group,\n    root: root\n  };\n}\n/**\n * Parse the data-layout attribute value\n */\nfunction parseLayoutMode(value) {\n  if (value === \"position\") return \"position\";\n  if (value === \"size\") return \"size\";\n  if (value === \"preserve-aspect\") return \"preserve-aspect\";\n  return \"both\";\n}\n/**\n * Clean up projection nodes for specific elements.\n * If elementsToCleanup is provided, only those elements are cleaned up.\n * If not provided, all nodes are cleaned up.\n *\n * This allows persisting elements to keep their nodes between animations,\n * matching React's behavior where nodes persist for elements that remain in the DOM.\n */\nfunction cleanupProjectionTree(context, elementsToCleanup) {\n  const elementsToProcess = elementsToCleanup ? [...context.nodes.entries()].filter(([el]) => elementsToCleanup.has(el)) : [...context.nodes.entries()];\n  for (const [element, node] of elementsToProcess) {\n    context.group.remove(node);\n    node.unmount();\n    // Only clear from activeProjectionNodes if this is still the active node.\n    // A newer animation might have already taken over.\n    if (activeProjectionNodes.get(element) === node) {\n      activeProjectionNodes.delete(element);\n    }\n    context.nodes.delete(element);\n    context.visualElements.delete(element);\n  }\n}\nexport { buildProjectionTree, cleanupProjectionTree };","map":{"version":3,"names":["HTMLProjectionNode","HTMLVisualElement","nodeGroup","getLayoutId","addScaleCorrector","correctBorderRadius","correctBoxShadow","scaleCorrectorAdded","activeProjectionNodes","WeakMap","ensureScaleCorrectors","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow","getDepth","element","depth","current","parentElement","findProjectionParent","nodeCache","parent","node","get","undefined","createProjectionNode","options","transition","existingNode","visualElement","nodeTransition","duration","ease","setOptions","animate","instance","mount","latestValues","visualState","renderState","transformOrigin","transform","style","vars","presenceContext","props","layout","projection","set","buildProjectionTree","elements","existingContext","nodes","Map","visualElements","group","defaultTransition","sharedTransitions","sorted","sort","a","b","root","has","layoutId","layoutMode","getAttribute","nodeOptions","animationType","parseLayoutMode","add","value","cleanupProjectionTree","context","elementsToCleanup","elementsToProcess","entries","filter","el","remove","unmount","delete"],"sources":["C:/Users/angel/OneDrive/Documents/my-portfolio/node_modules/motion-dom/dist/es/layout/projection-tree.mjs"],"sourcesContent":["import { HTMLProjectionNode } from '../projection/node/HTMLProjectionNode.mjs';\nimport { HTMLVisualElement } from '../render/html/HTMLVisualElement.mjs';\nimport { nodeGroup } from '../projection/node/group.mjs';\nimport { getLayoutId } from './get-layout-elements.mjs';\nimport { addScaleCorrector } from '../projection/styles/scale-correction.mjs';\nimport { correctBorderRadius } from '../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../projection/styles/scale-box-shadow.mjs';\n\nlet scaleCorrectorAdded = false;\n/**\n * Track active projection nodes per element to handle animation interruption.\n * When a new animation starts on an element that already has an active animation,\n * we need to stop the old animation so the new one can start from the current\n * visual position.\n */\nconst activeProjectionNodes = new WeakMap();\nfunction ensureScaleCorrectors() {\n    if (scaleCorrectorAdded)\n        return;\n    scaleCorrectorAdded = true;\n    addScaleCorrector({\n        borderRadius: {\n            ...correctBorderRadius,\n            applyTo: [\n                \"borderTopLeftRadius\",\n                \"borderTopRightRadius\",\n                \"borderBottomLeftRadius\",\n                \"borderBottomRightRadius\",\n            ],\n        },\n        borderTopLeftRadius: correctBorderRadius,\n        borderTopRightRadius: correctBorderRadius,\n        borderBottomLeftRadius: correctBorderRadius,\n        borderBottomRightRadius: correctBorderRadius,\n        boxShadow: correctBoxShadow,\n    });\n}\n/**\n * Get DOM depth of an element\n */\nfunction getDepth(element) {\n    let depth = 0;\n    let current = element.parentElement;\n    while (current) {\n        depth++;\n        current = current.parentElement;\n    }\n    return depth;\n}\n/**\n * Find the closest projection parent for an element\n */\nfunction findProjectionParent(element, nodeCache) {\n    let parent = element.parentElement;\n    while (parent) {\n        const node = nodeCache.get(parent);\n        if (node)\n            return node;\n        parent = parent.parentElement;\n    }\n    return undefined;\n}\n/**\n * Create or reuse a projection node for an element\n */\nfunction createProjectionNode(element, parent, options, transition) {\n    // Check for existing active node - reuse it to preserve animation state\n    const existingNode = activeProjectionNodes.get(element);\n    if (existingNode) {\n        const visualElement = existingNode.options.visualElement;\n        // Update transition options for the new animation\n        const nodeTransition = transition\n            ? { duration: transition.duration, ease: transition.ease }\n            : { duration: 0.3, ease: \"easeOut\" };\n        existingNode.setOptions({\n            ...existingNode.options,\n            animate: true,\n            transition: nodeTransition,\n            ...options,\n        });\n        // Re-mount the node if it was previously unmounted\n        // This re-adds it to root.nodes so didUpdate() will process it\n        if (!existingNode.instance) {\n            existingNode.mount(element);\n        }\n        return { node: existingNode, visualElement };\n    }\n    // No existing node - create a new one\n    const latestValues = {};\n    const visualElement = new HTMLVisualElement({\n        visualState: {\n            latestValues,\n            renderState: {\n                transformOrigin: {},\n                transform: {},\n                style: {},\n                vars: {},\n            },\n        },\n        presenceContext: null,\n        props: {},\n    });\n    const node = new HTMLProjectionNode(latestValues, parent);\n    // Convert AnimationOptions to transition format for the projection system\n    const nodeTransition = transition\n        ? { duration: transition.duration, ease: transition.ease }\n        : { duration: 0.3, ease: \"easeOut\" };\n    node.setOptions({\n        visualElement,\n        layout: true,\n        animate: true,\n        transition: nodeTransition,\n        ...options,\n    });\n    node.mount(element);\n    visualElement.projection = node;\n    // Track this node as the active one for this element\n    activeProjectionNodes.set(element, node);\n    return { node, visualElement };\n}\n/**\n * Build a projection tree from a list of elements\n */\nfunction buildProjectionTree(elements, existingContext, options) {\n    ensureScaleCorrectors();\n    const nodes = existingContext?.nodes ?? new Map();\n    const visualElements = existingContext?.visualElements ?? new Map();\n    const group = existingContext?.group ?? nodeGroup();\n    const defaultTransition = options?.defaultTransition;\n    const sharedTransitions = options?.sharedTransitions;\n    // Sort elements by DOM depth (parents before children)\n    const sorted = [...elements].sort((a, b) => getDepth(a) - getDepth(b));\n    let root = existingContext?.root;\n    for (const element of sorted) {\n        // Skip if already has a node\n        if (nodes.has(element))\n            continue;\n        const parent = findProjectionParent(element, nodes);\n        const layoutId = getLayoutId(element);\n        const layoutMode = element.getAttribute(\"data-layout\");\n        const nodeOptions = {\n            layoutId: layoutId ?? undefined,\n            animationType: parseLayoutMode(layoutMode),\n        };\n        // Use layoutId-specific transition if available, otherwise use default\n        const transition = layoutId && sharedTransitions?.get(layoutId)\n            ? sharedTransitions.get(layoutId)\n            : defaultTransition;\n        const { node, visualElement } = createProjectionNode(element, parent, nodeOptions, transition);\n        nodes.set(element, node);\n        visualElements.set(element, visualElement);\n        group.add(node);\n        if (!root) {\n            root = node.root;\n        }\n    }\n    return {\n        nodes,\n        visualElements,\n        group,\n        root: root,\n    };\n}\n/**\n * Parse the data-layout attribute value\n */\nfunction parseLayoutMode(value) {\n    if (value === \"position\")\n        return \"position\";\n    if (value === \"size\")\n        return \"size\";\n    if (value === \"preserve-aspect\")\n        return \"preserve-aspect\";\n    return \"both\";\n}\n/**\n * Clean up projection nodes for specific elements.\n * If elementsToCleanup is provided, only those elements are cleaned up.\n * If not provided, all nodes are cleaned up.\n *\n * This allows persisting elements to keep their nodes between animations,\n * matching React's behavior where nodes persist for elements that remain in the DOM.\n */\nfunction cleanupProjectionTree(context, elementsToCleanup) {\n    const elementsToProcess = elementsToCleanup\n        ? [...context.nodes.entries()].filter(([el]) => elementsToCleanup.has(el))\n        : [...context.nodes.entries()];\n    for (const [element, node] of elementsToProcess) {\n        context.group.remove(node);\n        node.unmount();\n        // Only clear from activeProjectionNodes if this is still the active node.\n        // A newer animation might have already taken over.\n        if (activeProjectionNodes.get(element) === node) {\n            activeProjectionNodes.delete(element);\n        }\n        context.nodes.delete(element);\n        context.visualElements.delete(element);\n    }\n}\n\nexport { buildProjectionTree, cleanupProjectionTree };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}